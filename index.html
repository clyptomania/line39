<!DOCTYPE html>
<html lang="en,de">
<head>
	<meta name="generator" content="Hugo 0.69.0" />
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Line Thirty Nine by Annika Storch</title>

</head>
    
<body style="overflow: hidden; scrollbar-width: none; background-color: rgb(0, 0, 0);">
 

<script src="assets/js-libraries/dat.gui.min.js"></script>
<script src="assets/js-libraries/jquery.js"></script>
<script src="assets/js-libraries/lodash.js"></script>

<canvas id="c"></canvas>

<script>
let canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
var W = 1200;
var H = 1920;
canvas.width = W;
canvas.height = H;

var exampleSocket = new WebSocket("ws://127.0.0.1:8123/kinect_position");
// a message looks like this: "index,x0,y0,x1,y1,...,xn,yn"
exampleSocket.onmessage = function (event) {
    const data = event.data.split(",");
    agents = [];
    for (let i=1; i<data.length; i+=2) {
      if (config.orientation == 1) {
        // default orientation. No mapping required
        let agent = {
          x: data[i]*W, // x (beamer)
          y: data[i+1]*H // y (beamer)
        }
        agents.push(agent);
      }
      else if (config.orientation == 2) {
        // 90 degree clockwise
        let agent = {
          x: mapHeighttoWidthReversed(data[i+1]),
          y: mapWidthtoHeight(data[i])
        }
        agents.push(agent);
      }
      else if (config.orientation == 3) {
        // 180 degree clockwise
        let agent = {
          x: (1-data[i])*W,
          y: (1-data[i+1])*H
        }
        agents.push(agent);
      }
      else if (config.orientation == 4) {
        // 270 degree clockwise
        let agent = {
          x: mapHeighttoWidth(data[i+1]),
          y: mapWidthtoHeightReversed(data[i])
        }
        agents.push(agent);
      }
    }
    // agents.push(mouse);
}

function mapWidthtoHeight(width) {
  return width * H;
}

function mapWidthtoHeightReversed(width) {
  return (1 - width) * H;
}

function mapHeighttoWidth(height) {
  return height * W;
}

function mapHeighttoWidthReversed(height) {
  return (1 - height) * W;
}

function mid(){
    const args = Array.from(arguments);
    if(args.length < 3) return args[0] || 0;
    const sorted = args.slice().sort((a,b)=> a - b);
    return sorted[Math.round((sorted.length - 1) / 2)];
}


// Pythagoras: Length of vector defined by x and y
const PY = (x,y) => Math.sqrt(Math.pow(Math.abs(x),2) + Math.pow(Math.abs(y),2));

const fpsHelper = function(onSecond){
    let lastSec = Date.now();
    let frames = 0;
    let fps = 0;
    return {
        onFrame: ()=>{
            if(((Date.now() - lastSec) / 1000) > 1) {
                lastSec = Date.now();
                fps = frames;
                frames = 0;
                if(onSecond)
                onSecond(fps);
            } else {
                frames += 1;
            }
        },
        getFPS: () => {
            return fps;
        }
    }
}

// const mouse = {
//   x: W / 2,
//   y: H / 2
// }

agents = [
  // {
  //     x: W / 1,
  //     y: H / 1
  // },
  // mouse
];


const config = {
  nPoints: 50,
  nLines: 39,
  radius: 350,
  padding: 0,
  showFPS: false,
  showPoints: false,
  maxSpeed: 90,
  snapToHomePx: 1,
  forceDamping: 8,
  orientation: 2
}
// window.onload = function(fa){
// var gui = new dat.GUI({ closed: false, name:"config" });
// gui.add(config,"nPoints",3,50).step(1).onFinishChange(function(val){
//   debouncedInit();
// });
// gui.add(config,"nLines",3,50).step(1).onFinishChange(function(val){
//   console.log('finish',val,config)
//   debouncedInit();
// });;
// gui.add(config,"radius",50,2000).step(1);
// gui.add(config,"padding",0).step(1).onFinishChange(function(val){
//   console.log(val)
//   debouncedUpdateX();
// });
// gui.add(config,"showFPS");
// gui.add(config,"showPoints");
// gui.add(config,"maxSpeed", 5, 100);
// gui.add(config,"snapToHomePx", 0, 10);
// gui.add(config,"forceDamping", 1, 10);
// gui.add(config,"orientation", 1, 4).step(1);


// }
let pointsPerLine = 20;
let linesInScreen = 20;
let lines = [];
let homesX = [];
let homesY = [];
let padding = 0;
let max = 30;
let radius = 2000;
let fpsObj = fpsHelper();
let debug = {
  fps: false,
  dots: false,
};

let rAF = null;


// TODO: The points for each vertical line are calculated here.
// How can two or more x and y coordinates be implemented?
function updateLine(line,homeX){
  let point, desiredX, desiredY, desiredH, desiredForce, desiredAngle, hvx, hvy, mvx, mvy, x, y, homeY;
  let radius = config.radius;
  let maxSpeed = config.maxSpeed;
  for(var j = line.length - 1; j >= 0; j--){
    let vxList = [];
    let vyList = [];
    point = line[j];
    for(let i = 0; i<agents.length; i++) {
      let agent = agents[i];
      let vx, vy;
      x = point.x;
      y = point.y;
      hvx = 0, hvy = 0;
      
      homeY = homesY[j];
      if(x !== homeX || y !== homeY) {
        desiredX = homeX - x;
        desiredY = homeY - y;
        desiredH = PY(desiredX,desiredY);
        desiredForce = Math.max(desiredH * 0.2,1); // returns the largest number given as input parameters
        desiredAngle = Math.atan2(desiredY,desiredX); // math.atan2 returns the arctangent of the quotient of its arguments, as a numeric value between PI and -PI radians
        hvx = desiredForce * Math.cos(desiredAngle);
        hvy = desiredForce * Math.sin(desiredAngle);
      }
      
      mvx = 0, mvy = 0;
      desiredX = x - agent.x;
      desiredY = y - agent.y;
      if(!(desiredX > radius || desiredY > radius || desiredY < -radius || desiredX < -radius)) {
        desiredAngle = Math.atan2(desiredY,desiredX);
        // desiredAngleB = Math.atan2(desiredBY,desiredBX);
        desiredH = PY(desiredX,desiredY);
        // desiredHB = PY(desiredBX,desiredBY);
        desiredForce =  Math.max(0,Math.min(radius - desiredH,radius));
        // desiredForceB =  Math.max(0,Math.min(radius - desiredHB,radius));
        mvx = desiredForce * Math.cos(desiredAngle);
        mvy = desiredForce * Math.sin(desiredAngle);
      }
      
      vx = Math.round(mid((mvx + hvx) * 0.9, maxSpeed, -maxSpeed));
      vy = Math.round(mid((mvy + hvy) * 0.9, maxSpeed, -maxSpeed));
      vxList.push(vx);
      vyList.push(vy);
    }
    // The following code computes the sum of each list
    let vx = vxList.reduce((total, curVal) => total + curVal, 0);
    let vy = vyList.reduce((total, curVal) => total + curVal, 0);

    if(vx != 0) {
      point.x += vx/config.forceDamping;
    }
    if(vy != 0){
      point.y += vy/config.forceDamping;
    }
    if (Math.abs(point.x-homeX) < config.snapToHomePx) {
      point.x = homeX;
    }
    if (Math.abs(point.y-homeY) < config.snapToHomePx) {
      point.y = homeY;
    }
    line[j] = point;
  }

  return line;
}

function timer(){
  ctx.clearRect(0,0,W,H);
  if(config.showFPS){
     fpsObj.onFrame();
      ctx.fillStyle = 'red';
      ctx.textAlign="start";
      ctx.textBaseline="top";
     ctx.font="50px Helvetica";
     ctx.fillText(fpsObj.getFPS(),50,50);
  }
  let line, xc,yc, cur, curX, curY, next, dot;
  // In the following loop every line is drawn using some sort of bezier-technique
  for(var i = lines.length - 1; i >= 0; i--){
    
    line = updateLine(lines[i],homesX[i]);
    lines[i] = line;
    ctx.beginPath();
    ctx.strokeStyle = 'white';
    ctx.moveTo(line[line.length - 1].x,line[line.length - 1].y);
    // In this loop some sort of bezier-curve is drawn between two points
    for(var j = line.length - 2; j > 1; j--){
      cur  = line[j];
      curX = cur.x;
      curY = cur.y;
      next = line[j - 1];
      xc = (curX + next.x) / 2;
      yc = (curY + next.y) / 2;
      
      
      ctx.quadraticCurveTo(curX,curY,xc,yc);
    }
    
    ctx.quadraticCurveTo(line[j].x,line[j].y, line[j - 1].x, line[j - 1].y);
    ctx.stroke();
    // In the following if-block every point is drawn (if the user wishes to)
    if(config.showPoints) {
      for(j = line.length - 1; j >= 0; j--){
        dot =  line[j];
        ctx.beginPath();
        ctx.fillStyle ='white';
        ctx.arc(dot.x, dot.y, 1, 0, 2 * Math.PI);
        ctx.fill();
      }
    }

    }
    // Keep at least one agent in the list (out of bounds) so that the animation does not freeze
    agents = [{
      x: -10*W,
      y: -10*H
    }]
  rAF = requestAnimationFrame(timer)

}
function point(x,y){
  return {
    x: x,
    y: y,
    hy: y,
    hx: x,
  }
}
function updateX(){
  let line, calcPad;
  if(rAF) {
    cancelAnimationFrame(rAF);
    rAF = null;
  }
  // Amount of "padding"-pixels left and right
  calcPad = (W * config.padding) / 100;
  homesX = [];
  for(var i = config.nLines; i >= 0; i--){
    x = calcPad + (((W - calcPad * 2) / config.nLines) * i);
    homesX.push(x);
  }
  timer();
}

function init(){

  if(rAF) {
    cancelAnimationFrame(rAF);
    rAF = null;
  }
  lines = [];
  homesX = [];
  homesY = [];
  let line = [], y = 0, x = 0;
  let calcPad = (W * config.padding) / 100;
  for(var i = config.nLines; i >= 0; i--){
    line = [];
    
    x = calcPad + (((W - calcPad * 2) / config.nLines) * i);
    homesX.push(x);
    for(var j = config.nPoints; j >= 0; j--){
      line.push(point(x,Math.round((H / config.nPoints )* j)));
      if(i === 0) {
        homesY.push(Math.round((H / config.nPoints ) * j));
      }
    }
    if(i == 0){
      
    }
    lines.push(line);
  }
  timer();
}


// TODO: WTH is debounce? And what does "_." mean?
const debouncedInit = _.debounce(init, 200)
const debouncedUpdateX = _.debounce(updateX, 200)


// window.addEventListener('mousemove',(e)=>{
//  mouse.x = e.clientX;
//  mouse.y = e.clientY;
// });

window.addEventListener('resize', (e) => {
  canvas.width = W;
  canvas.height = H;
  init();
});

init();
</script>


</body>