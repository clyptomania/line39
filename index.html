<!DOCTYPE html>
<html lang="en,de">
<head>
	<meta name="generator" content="Hugo 0.69.0" />
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Line Thirty Nine by Annika Storch</title>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/lines.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.css">

</head>
    
<body style="background-color: rgb(0, 0, 0);">
 

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.5/lodash.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.3/dat.gui.min.js"></script>

<canvas id="c"></canvas>

<script>
let canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
var W = 1080;
var H = 1404;
canvas.width = W;
canvas.height = H;

var exampleSocket = new WebSocket("ws://127.0.0.1:8123/kinect_position");
exampleSocket.onmessage = function (event) {
    console.log(event.data.split(","));
    const [i, ax, ay, bx, by] = event.data.split(",");
    agent.x = ax;
    agent.y = ay;
    agent.bx = bx;
    agent.by = by;
    console.log("Done");
}


function mid(){
    const args = Array.from(arguments);
    if(args.length < 3) return args[0] || 0;
    const sorted = args.slice().sort((a,b)=> a - b);
    return sorted[Math.round((sorted.length - 1) / 2)];
}


// Pythagoras: Length of vector defined by x and y
const PY = (x,y) => Math.sqrt(Math.pow(Math.abs(x),2) + Math.pow(Math.abs(y),2),2);

const fpsHelper = function(onSecond){
    let lastSec = Date.now();
    let frames = 0;
    let fps = 0;
    return {
        onFrame: ()=>{
            if(((Date.now() - lastSec) / 1000) > 1) {
                lastSec = Date.now();
                fps = frames;
                frames = 0;
                if(onSecond)
                onSecond(fps);
            } else {
                frames += 1;
            }
        },
        getFPS: () => {
            return fps;
        }
    }
}

const agent = {
    x: W / 1,
    y: H / 1
}


const config = {
  nPoints: 20,
  nLines: 39,
  radius: 400,
  padding: 0,
  showFPS: false,
  showPoints: false,
  maxSpeed: 30,
}
window.onload = function(fa){
var gui = new dat.GUI({ closed: false, name:"config" });
gui.add(config,"nPoints",3,50).step(1).onFinishChange(function(val){
  debouncedInit();
});
gui.add(config,"nLines",3,50).step(1).onFinishChange(function(val){
  console.log('finish',val,config)
  debouncedInit();
});;
gui.add(config,"radius",50,2000).step(1);
gui.add(config,"padding",0).step(1).onFinishChange(function(val){
  console.log(val)
  debouncedUpdateX();
});
gui.add(config,"showFPS");
gui.add(config,"showPoints");
gui.add(config,"maxSpeed", 5, 100);


}
let pointsPerLine = 20;
let linesInScreen = 20;
let lines = [];
let homesX = [];
let homesY = [];
let padding = 0;
let max = 30;
let radius = 2000;
let fpsObj = fpsHelper();
let debug = {
  fps: false,
  dots: false,
};

let rAF = null;


// TODO: The points for each vertical line are calculated here.
// How can two or more x and y coordinates be implemented?
function updateLine(line,homeX){
  let point, desiredX, desiredY, desiredBX, desiredBY, desiredH, desiredHB, desiredForce, desiredForceB, desiredAngle, desiredAngleB, hvx, hvy, mvx, mvy, x, y, homeY, vx, vy;
  let radius = config.radius;
  let maxSpeed = config.maxSpeed;
  for(var j = line.length - 1; j >= 0; j--){
    point = line[j];
    x = point.x;
    y = point.y;
    hvx = 0, hvy = 0;
    
    homeY = homesY[j];
    if(x !== homeX || y !== homeY) {
      desiredX = homeX - x;
      desiredY = homeY - y;
      desiredH = PY(desiredX,desiredY);
      desiredForce = Math.max(desiredH * 0.2,1); // returns the largest number given as input parameters
      desiredAngle = Math.atan2(desiredY,desiredX); // math.atan2 returns the arctangent of the quotient of its arguments, as a numeric value between PI and -PI radians
      hvx = desiredForce * Math.cos(desiredAngle);
      hvy = desiredForce * Math.sin(desiredAngle);
    }
    
    mvx = 0, mvy = 0;
    desiredX = x - agent.x;
    desiredY = y - agent.y;
    desiredBX = x - agent.bx;
    desiredBY = y - agent.by;
    if(!(desiredX > radius || desiredY > radius || desiredY < -radius || desiredX < -radius)) {
      desiredAngle = Math.atan2(desiredY,desiredX);
      // desiredAngleB = Math.atan2(desiredBY,desiredBX);
      desiredH = PY(desiredX,desiredY);
      // desiredHB = PY(desiredBX,desiredBY);
      desiredForce =  Math.max(0,Math.min(radius - desiredH,radius));
      // desiredForceB =  Math.max(0,Math.min(radius - desiredHB,radius));
      mvx = desiredForce * Math.cos(desiredAngle);
      mvy = desiredForce * Math.sin(desiredAngle);
    }
    
    vx = Math.round(mid((mvx + hvx) * 0.9, maxSpeed, -maxSpeed));
    vy = Math.round(mid((mvy + hvy) * 0.9, maxSpeed, -maxSpeed));

    

    if(vx != 0) {
      point.x += vx;
    }
    if(vy != 0){
      point.y += vy;
    }
    line[j] = point;
  }

  return line;
}

function timer(){
  ctx.clearRect(0,0,W,H);
  if(config.showFPS){
     fpsObj.onFrame();
      ctx.fillStyle = 'red';
      ctx.textAlign="start";
      ctx.textBaseline="top";
     ctx.font="50px Helvetica";
     ctx.fillText(fpsObj.getFPS(),50,50);
  }
  let line, xc,yc, cur, curX, curY, next, dot;
  // In the following loop every line is drawn using some sort of bezier-technique
  for(var i = lines.length - 1; i >= 0; i--){
    
    line = updateLine(lines[i],homesX[i]);
    lines[i] = line;
    ctx.beginPath();
    ctx.strokeStyle = 'white';
    ctx.moveTo(line[line.length - 1].x,line[line.length - 1].y);
    // In this loop some sort of bezier-curve is drawn between two points
    for(var j = line.length - 2; j > 1; j--){
      cur  = line[j];
      curX = cur.x;
      curY = cur.y;
      next = line[j - 1];
      xc = (curX + next.x) / 2;
      yc = (curY + next.y) / 2;
      
      
      ctx.quadraticCurveTo(curX,curY,xc,yc);
    }
    
    ctx.quadraticCurveTo(line[j].x,line[j].y, line[j - 1].x, line[j - 1].y);
    ctx.stroke();
    // In the following if-block every point is drawn (if the user wishes to)
    if(config.showPoints) {
      for(j = line.length - 1; j >= 0; j--){
        dot =  line[j];
        ctx.beginPath();
        ctx.fillStyle ='white';
        ctx.arc(dot.x, dot.y, 1, 0, 2 * Math.PI);
        ctx.fill();
      }
    }

    }
  rAF = requestAnimationFrame(timer)

}
function point(x,y){
  return {
    x: x,
    y: y,
    hy: y,
    hx: x,
  }
}
function updateX(){
  let line, calcPad;
  if(rAF) {
    cancelAnimationFrame(rAF);
    rAF = null;
  }
  // Amount of "padding"-pixels left and right
  calcPad = (W * config.padding) / 100;
  homesX = [];
  for(var i = config.nLines; i >= 0; i--){
    x = calcPad + (((W - calcPad * 2) / config.nLines) * i);
    homesX.push(x);
  }
  timer();
}

function init(){
  
  if(rAF) {
    cancelAnimationFrame(rAF);
    rAF = null;
  }
  lines = [];
  homesX = [];
  homesY = [];
  let line = [], y = 0, x = 0;
  let calcPad = (W * config.padding) / 100;
  for(var i = config.nLines; i >= 0; i--){
    line = [];
    
    x = calcPad + (((W - calcPad * 2) / config.nLines) * i);
    homesX.push(x);
    for(var j = config.nPoints; j >= 0; j--){
      line.push(point(x,Math.round((H / config.nPoints )* j)));
      if(i === 0) {
        homesY.push(Math.round((H / config.nPoints ) * j));
      }
    }
    if(i == 0){
      
    }
    lines.push(line);
  }
  timer();
}


// TODO: WTH is debounce? And what does "_." mean?
const debouncedInit = _.debounce(init, 200)
const debouncedUpdateX = _.debounce(updateX, 200)


window.addEventListener('mousemove',(e)=>{
 mouse.x = e.clientX;
 mouse.y = e.clientY;
});

window.addEventListener('resize', (e) => {
  W = 1080;
  H = 1404;
  canvas.width = W;
  canvas.height = H;
  init();
});

init();
</script>


</body>